#!/bin/sh
# Copyright (c) 2013,2015-2019 Guillaume Outters
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

# Peut √™tre pour fiabiliser √† la fois int√©gr√© √† un cron et d√©clench√© sur changement de fichiers.

DELAI_MAX=20 # Combien de minutes est-on pr√™ts √† attendre qu'un verrou se rel√¢che avant d'abandonner?
VERROU_VIF=20 # √Ä partir de combien de secondes d'inactivit√© un verrou est-il consid√©r√© caduque (non maintenu)? On estime qu'il s'agit aussi du d√©lai maximal de mise en route (entre la cr√©ation du verrou et le lancement du rsync qui l'emprunte).

set -e

SCRIPTS="`command -v "$0"`" ; [ -x "$SCRIPTS" -o ! -x "$0" ] || SCRIPTS="$0" ; case "`basename "$SCRIPTS"`" in *.*) true ;; *sh) SCRIPTS="$1" ;; esac ; case "$SCRIPTS" in /*) ;; *) SCRIPTS="`pwd`/$SCRIPTS" ;; esac ; delie() { while [ -h "$SCRIPTS" ] ; do SCRIPTS2="`readlink "$SCRIPTS"`" ; case "$SCRIPTS2" in /*) SCRIPTS="$SCRIPTS2" ;; *) SCRIPTS="`dirname "$SCRIPTS"`/$SCRIPTS2" ;; esac ; done ; } ; delie ; MOI="$SCRIPTS" ; SCRIPTS="`dirname "$SCRIPTS"`" ; delie

#= Couleurs =#
couleur() { local couleur="$1" ; shift ; echo "[${couleur}m$*[0m" ; }
info() { couleur 90 "$@" ; }
alerte() { couleur 33 "$@" ; }
erreur() { couleur 31 "$@" ; }
tvb() { couleur 32 "$@" ; }
#- Couleurs -#

# Bute r√©cursivement toute une sous-arbo de processus (sans avoir besoin de taper tout le groupe).
bute()
{
	# Inspiration pioch√©e sur:
	# https://stackoverflow.com/a/26966800
	[ -z "$*" ] && return || true
	bute `IFS=\| ; ps axwwo ppid,pid | egrep "^ *($*) " | awk '{print$2}'`
	kill "$@"
}

uucommande()
{
	(
		echo "set -e"
		printf "commande='"
		(
			printf "%s" "$1"
			shift
			while [ $# -gt 0 ]
			do
				printf "\003%s" "$1"
				shift
			done
		) | sed -e "s/'/'\\\\''/g" -e "s/$/'/" # Certains sed tenant √† ajouter une derni√®re fin de ligne, autant que nous y mettions l'apostrophe fermante.
		echo # Pour les sed qui gentiment n'ont pas ins√©r√© une fin de ligne sur la pr√©c√©dente.
		printf 'IFS="\003"\n'
		echo '$commande'
	) | uuencode -m .exec.flute
}

adest()
{
	local nohup=non
	[ "x$1" = "x--nohup" ] && nohup=oui || true
	if echo "$dest" | grep -q '^[^/]*:'
	then
		local hote="`echo "$dest" | cut -d : -f 1`"
		local dossier="`echo "$dest" | cut -d : -f 2-`"
		local commande="`uucommande "$@"`"
		local exe="sh .exec.flute"
		[ $nohup = non ] || exe="nohup $exe < /dev/null > /dev/null 2>&1 &"
		( ssh "$hote" "cd \"$dossier\" ; echo '$commande' | uudecode ; $exe" )
	elif [ $nohup = oui ]
	then
		( cd "$dest" && nohup "$@" < /dev/null > /dev/null 2>&1 & )
	else
		( cd "$dest" && "$@" )
	fi
}

asource()
{
	( cd "$source" && "$@" )
}

internes()
{
	cat <<TERMINE
- /.*.flute
- /.*.??????
- /**/.*.??????
TERMINE
}

pondreDeverrouiller()
{
	echo "#!/bin/sh"
	sed -e '/^#= Couleurs/,/^#- Couleurs/!d' < "$MOI"
	
	case "$1" in
		source)
			cat <<TERMINE
if ps axo pid,command | egrep -q '^[ 	]*$$[ 	][ 	]*([^ 	]*sh )?[^ 	]*flute '
then
	[ -z "\$1" ] || info "(\$1: verrouill√© par la t√¢che locale $$ en cours d'ex√©cution)" >&2
	exit 1
fi
TERMINE
			;;
		dest)
			cat <<TERMINE
# -i: l'appelant souhaite que nous lui r√©pondions si nous avons √©t√© cr√©√©s par lui.
if [ "x\$1" = x-i ]
then
	appelant="\$2"
	shift ; shift
	if [ \$appelant = $idarbofactice ]
	then
		exit 0
	fi
fi
if ps axo command | grep -q '^[^ ]*rsync .*--link-dest .verrou.flute/$idarbofactice/'
then
	[ -z "\$1" ] || info "(\$1: verrouill√© par la t√¢che distante $idarbofactice en cours d'ex√©cution)" >&2
	exit 1
fi
TERMINE
			;;
	esac
	
	cat <<TERMINE
[ -z "\$1" ] || info "\$1: verrou caduque (la t√¢che qui l'a pos√© ne tourne plus); on le supprime." >&2
# Si le rsync n'existe plus, alors ce ./deverrouiller est caduque. Afin qu'il ne soit plus appel√©, on marque le dossier comme "en cours de constitution" ("donc ne cherchez pas ./deverrouiller, il n'existe peut-√™tre pas ou peut-√™tre pas compl√®tement").
touch .verrou.flute
exit 0
TERMINE
}

verrouiller()
{
	local ou="$1"
	local libelle="$2"
	if $ou sh -c '[ -d .verrou.flute ] || ! mkdir .verrou.flute'
	then
		# Si le verrou existe, est-il r√©cent (pas encore pr√™t √† l'usage)?
		if $ou find .verrou.flute -maxdepth 0 -mtime -${VERROU_VIF}s | grep -q .
		then
			[ -z "$libelle" ] || info "($libelle: verrou pos√© par une t√¢che concurrente tout juste lanc√©e)" >&2
			return 1
		fi
		# S'il peut √™tre consid√©r√© comme d√©finitif, il est cens√© contenir un script v√©rifiant s'il (le verrou) est encore exploit√©.
		if $ou test -x .verrou.flute/deverrouiller && ! $ou .verrou.flute/deverrouiller "$libelle"
		then
			return 1
		fi
	fi
	
	return 0
}

biverrou()
{
	# NOTE: Verrouillage
	# Un dossier peut √™tre verrouill√©, aussi bien comme source que comme destination. Chaque typologie de verrou embarque son d√©verrouilleur:
	# - par PID pour le source (si ce PID tourne encore au moment de la tentative de d√©verrouillage, c'est qu'il bosse)
	# - par option pass√©e √† rysnc pour la destination (si un ps | grep cette option voit quelque chose, c'est qu'il bosse)
	verrouiller asource "√† la source ($source)" || return 1
	if ! verrouiller adest "√† la cible ($dest)"
	then
		# Bon c'est foutu: on sort, non sans avoir lib√©r√© notre verrou local.
		rm -R "$source/.verrou.flute"
		return 1
	fi
	# On a le verrou! On y pr√©pare notre possible "mort trop brutale pour faire le m√©nage".
	pondreDeverrouiller source > "$source/.verrou.flute/deverrouiller" && chmod a+x "$source/.verrou.flute/deverrouiller"
	pondreDeverrouiller dest | adest sh -c "cat > .verrou.flute/deverrouiller && chmod a+x .verrou.flute/deverrouiller && mkdir .verrou.flute/$idarbofactice/"
}

faire()
{
	local prefixe=
	[ "x$1" = x-p ] && shift && prefixe="$1" && shift || true
source="$1"
dest="$2"
	
	# Tentative d'acqu√©rir le verrou.
	# N√©cessaire car on n'est peut-√™tre pas le seul √† alimenter la destination‚Ä¶ Voire elle est en train d'alimenter une de ses propres cibles, voire m√™me c'est peut-√™tre nous sa cible.
	
	local tmax="`date +%s`"
	tmax="`expr $tmax + \( $DELAI_MAX \* 60 \)`"
	
	idarbofactice="`hostname`.$$"
	
	while ! biverrou
	do
		if [ `date +%s` -gt $tmax ]
		then
			alerte "# Impossible d'acqu√©rir le verrou au bout de $DELAI_MAX mn." >&2
			return 3
		fi
		sleep $VERROU_VIF
	done
	trap menage0 EXIT
	trap menage1 INT TERM
	
	_faire
	
	deverrouiller
}

menage0()
{
	deverrouiller
	exit 0
}

menage1()
{
	local err=$?
	[ $err -ne 0 ] || err=1
	deverrouiller
	trap - EXIT
	exit $err
}

deverrouiller()
{
	rm -R "$source/.verrou.flute" || true
	adest sh -c "[ -x .verrou.flute ] && ./.verrou.flute -i $idarbofactice && rm .verrou.flute || true" || true # Attention, petite possibilit√© qu'on supprime le mauvais si une autre flute est lanc√©e pile entre notre .verrou.flute -i, et notre rm. Mais ce ne serait vraiment pas de bol.
}

_faire()
{

# On √©vite de transmettre:
# - nos fichiers de travail
# - les fichiers temporaires d'un autre rsync qui serait en train de nous alimenter
	( adest cat .deja.flute 2> /dev/null || true ) > "$source/$prefixe.ddeja.flute"
while true
do
		# On pr√©pare la liste de ce qui aura √©t√© fait apr√®s ce tour de boucle *avant* le transfert; ainsi, si de nouveaux fichiers apparaissent alors que l'on transf√®re, ils ne feront pas partie de la liste et, par s√©curit√©, seront donc r√©√©mis au prochain tour de boucle.
		# Il s'agit de la liste des d√©j√† pr√©sents √† destination + les fichiers pr√©sents √† source maintenant qui ne sont pas d√©j√† √† destination.
		sort < "$source/$prefixe.ddeja.flute" > "$source/$prefixe.ddeja.triees.flute"
		( cd "$source" && find . -type f -not -name "*.flute" | sed -e 's#^./#- /#' ) | sort > "$source/$prefixe.ici.triees.flute"
		diff "$source/$prefixe.ddeja.triees.flute" "$source/$prefixe.ici.triees.flute" | grep '^> ' | cut -c 3- > "$source/$prefixe.nouveaux.flute"
		# Tant qu'√† faire, si on a rep√©r√© de nouveaux fichiers chez nous, on peut les marquer comme d√©j√† faits: √ßa √©vitera que notre cible, en retour, croie bon de nous les transf√©rer.
		touch "$source/.deja.flute"
		sort < "$source/.deja.flute" > "$source/$prefixe.sdeja.triees.flute"
		diff "$source/$prefixe.sdeja.triees.flute" "$source/$prefixe.ici.triees.flute" | grep '^> ' | cut -c 3- >> "$source/.deja.flute"
		# Si rien de nouveau, on sort.
		[ -s "$source/$prefixe.nouveaux.flute" ] || break
		info "`wc -l < "$source/$prefixe.nouveaux.flute" | tr -d '\011 '` nouveaux fichiers √† transf√©rer"
		# Si c'est un rsync distant, il faut mettre des \ devant les espaces (merci rsync utilisant ssh et son interpr√©tation shell!).
		destrsync="`echo "$dest" | sed -e '/^[^/]*:/s# #\\\\ #g'`"
		( internes ; cat "$source/$prefixe.ddeja.flute" ) | rsync --link-dest .verrou.flute/$idarbofactice/ --exclude-from=- -av "$source/" "$destrsync/"
		# Le transfert s'√©tant bien pass√©, on peut pousser la liste .deja.flute actualis√©e.
		# On utilise rsync, qui ne remplacera le fichier distant qu'√† l'issue du bon transfert.
		cat "$source/$prefixe.nouveaux.flute" >> "$source/$prefixe.ddeja.flute"
		rsync -a "$source/$prefixe.ddeja.flute" "$destrsync/.deja.flute"
		apres
	sleep 2
		[ `find "$source" -type f -newer "$source/$prefixe.ddeja.flute" -not -name "*.flute" | wc -l` -ne 0 ] || break
done
}

apres()
{
	local commande="[ ! -x .post.flute ] || ./.post.flute"
	local optionsADest=
	[ $apresLancerFlute = non ] || commande="$commande ; if command -v flute > /dev/null 2> /dev/null && find . -maxdepth 1 -name '*.conf.flute' | grep -q . ; then flute . ; fi"
	if [ $apresMasque = oui ]
	then
		optionsADest=--nohup
	else
		info "Lancement du .post.flute`[ $apresLancerFlute = non ] || printf " et de flute"` sur $dest"
	fi
	adest $optionsADest sh -c "$commande"
}

faireConf()
{
	local conf="$1" source="`dirname "$1"`"
	local prefixe="`basename "$conf" .conf.flute`"
	[ "`basename "$conf"`" != .conf.flute ] || prefixe=
	faire -p "$prefixe" "$source" "`cat "$conf"`"
}

# Petit roff.
# Principalement destin√© √† afficher l'aide "auSecours".
proff()
{
	if [ -z "$COLUMNS" -o "0$COLUMNS" -lt 32 ]
	then
		cat
	else
		local cars="`printf "%0$COLUMNS.${COLUMNS}s" "" | tr ' 0' ..`"
		local sepi="`printf '\003'`" # S√©parateur indentation (entre l'indentation et le corps de texte).
		local sepm="`printf '\004'`" # S√©parateur massicot (apr√®s $COLUMNS caract√®res).
		local esp="`printf ' \t'`"
		# Pour chaque ligne un peu longue, on va:
		# 1. placer sepi.
		# 2. tenter de placer notre sepm.
		# 3. en cas d'√©chec (ligne suffisamment courte), on sort.
		# 4. essayer de recaler sepm √† l'espace qui le pr√©c√®de (techniquement: prendre tout ce qui est entre l'espace et sepm, et le d√©placer apr√®s sepm).
		# 5. copier le d√©coupage dans le "hold space".
		# 6. afficher la premi√®re partie.
		# 7. r√©cup√©rer le "hold space" pour travailler dessus.
		# 8. retravailler l'indentation: les listes √† puces deviennent des espaces.
		# 9. et repartir pour un tour en 2. (on conserve le sepi d'une passe √† l'autre).
		# √Ä FAIRE: g√©rer l'UTF-8. 80 caract√®res et 80 octets, √ßa n'est pas la m√™me chose.
		sed -E -e "/$cars./{
s|^[$esp]*(#[$esp]*)?((-\\|[0-9][0-9]*\.)[$esp]*)?|&$sepi|
t-)
:-)
s|^($cars.)|\\1$sepm|
t-/
s|$sepi||
b
:-/
s|$sepm[$esp][$esp]*| $sepm|
s| ([^ $sepi]*)$sepm|$sepm\\1|
h
s|$sepi||
s|$sepm.*||
p
g
s|$sepi[^$sepm]*$sepm|$sepi|
:-o
s|^([^$sepi]*)[^$sepi$esp#]|\\1 |
t-o
b-)
}"
	fi
}

auSecours()
{
	local moi="`basename "$0"`"
	proff >&2 <<TERMINE
# $moi ¬© 2013,2015-2019 Guillaume Outters
# Synchronisation unidirectionnelle de dossiers, chaque fichier n'√©tant jamais transf√©r√© qu'une fois:
# - s'il est modifi√© √† la source, il ne sera pas retransf√©r√© (la destination peut donc servir de coffre-fort de l'√©tat originel du fichier)
# - s'il est supprim√© √† destination, il ne sera pas retransf√©r√© (une photo jug√©e mauvaise, ou d√©plac√©e pour classement dans un dossier local, ne risque pas de resurgir).
# Source et destination sont verrouill√©es durant le transfert: lancer en m√™me temps une synchro et sa r√©ciproque n'aura donc pas d'incidence malheureuse.

Utilisation:
  $moi <.*.conf.flute>+
  $moi <source> <dest>
  $moi <source>
Param√®tres:
  <.*.conf.flute>
    Fichier de configuration, plac√© dans un dossier source, et ayant pour contenu une destination (chemin local ou URL SSH / scp / rsync).
  <source>
    Dossier source (chemin local ou URL SSH / scp / rsync).
    Dans la troisi√®me forme (sans <dest>), chaque fichier .conf.flute de <source> sera consid√©r√© comme porteur d'une <dest>.
  <dest>
    Dossier destination (chemin local ou URL SSH / scp / rsync).
TERMINE
	exit 1
}

tifs()
{
	unset IFS
	"$@"
}

analyserParametres()
{
	sep="`printf "\003"`"
	
	apresLancerFlute=oui
	apresMasque=oui
	aFaire=
	while [ $# -gt 0 ]
	do
		case "$1" in
			-h|--help) auSecours ;;
			-n) apresLancerFlute=non ;;
			-f) apresMasque=non ;;  # --foreground
			*)
				if [ -z "$aFaire" ]
				then
					aFaire="$1"
				else
					aFaire="$aFaire$sep$1"
				fi
				;;
		esac
		shift
	done
}

tourner()
{
	if [ $# -eq 2 -a -d "$1" -a -d "$2" ] && [ "`find "$1" "$2" -name ".*.conf.flute" | wc -l`" -eq 0 ] # Le && plut√¥t que -a, car sh sous FreeBSD 10 √©value le find avant m√™me d'avoir v√©rifi√© que $# -eq 2 et ce sont des dossiers.
	then
		# Ancienne sauce: source, destination pr√©cis√©es sur la ligne de commande. Comment distinguer de deux dossiers (sources) √† synchroniser?
		faire "$1" "$2"
	elif [ $# = 0 ]
	then
		auSecours
	else
		for d in "$@"
		do
			if [ -f "$d" ]
			then
				faireConf "$d"
			else
				find "$d" -maxdepth 1 -name "*.conf.flute" | \
				(
					trouve=
					while read conf
					do
						trouve=1
						faireConf "$conf"
					done
					[ -n "$trouve" ] || erreur "Aucun fichier .conf.flute dans $d" >&2
				)
			fi
		done
	fi
}

analyserParametres "$@"
IFS="$sep"
tifs tourner $aFaire

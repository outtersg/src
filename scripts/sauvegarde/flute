#!/bin/sh
# Copyright (c) 2013,2015-2019 Guillaume Outters
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

# Peut √™tre pour fiabiliser √† la fois int√©gr√© √† un cron et d√©clench√© sur changement de fichiers.

DELAI_MAX=20 # Combien de minutes est-on pr√™ts √† attendre qu'un verrou se rel√¢che avant d'abandonner?

set -e

SCRIPTS="`command -v "$0"`" ; [ -x "$SCRIPTS" -o ! -x "$0" ] || SCRIPTS="$0" ; case "`basename "$SCRIPTS"`" in *.*) true ;; *sh) SCRIPTS="$1" ;; esac ; case "$SCRIPTS" in /*) ;; *) SCRIPTS="`pwd`/$SCRIPTS" ;; esac ; delie() { while [ -h "$SCRIPTS" ] ; do SCRIPTS2="`readlink "$SCRIPTS"`" ; case "$SCRIPTS2" in /*) SCRIPTS="$SCRIPTS2" ;; *) SCRIPTS="`dirname "$SCRIPTS"`/$SCRIPTS2" ;; esac ; done ; } ; delie ; MOI="$SCRIPTS" ; SCRIPTS="`dirname "$SCRIPTS"`" ; delie

#= Couleurs =#
couleur() { local couleur="$1" ; shift ; echo "[${couleur}m$*[0m" ; }
info() { couleur 90 "$@" ; }
alerte() { couleur 33 "$@" ; }
erreur() { couleur 31 "$@" ; }
tvb() { couleur 32 "$@" ; }
#- Couleurs -#

uucommande()
{
	(
		echo "set -e"
		printf "commande='"
		(
			printf "%s" "$1"
			shift
			while [ $# -gt 0 ]
			do
				printf "\003%s" "$1"
				shift
			done
		) | sed -e "s/'/'\\\\''/g" -e "s/$/'/" # Certains sed tenant √† ajouter une derni√®re fin de ligne, autant que nous y mettions l'apostrophe fermante.
		echo # Pour les sed qui gentiment n'ont pas ins√©r√© une fin de ligne sur la pr√©c√©dente.
		printf 'IFS="\003"\n'
		echo '$commande'
	) | uuencode -m .exec.flute
}

adest()
{
	if echo "$dest" | grep -q '^[^/]*:'
	then
		local hote="`echo "$dest" | cut -d : -f 1`"
		local dossier="`echo "$dest" | cut -d : -f 2-`"
		local commande="`uucommande "$@"`"
		( ssh "$hote" "cd \"$dossier\" ; echo '$commande' | uudecode ; sh .exec.flute" )
	else
		( cd "$dest" && "$@" )
	fi
}

asource()
{
	( cd "$source" && "$@" )
}

internes()
{
	cat <<TERMINE
- /.*.flute
- /.*.??????
- /**/.*.??????
TERMINE
}

pondreDeverrouiller()
{
	echo "#!/bin/sh"
	sed -e '/^#= Couleurs/,/^#- Couleurs/!d' < "$MOI"
	
	case "$1" in
		source)
			cat <<TERMINE
if ps axo pid,command | egrep -q '^$$[ 	][ 	]*([^ 	]*sh )?[^ 	]*flute '
then
	[ -z "\$1" ] || info "(\$1: verrouill√© par la t√¢che locale $$ en cours d'ex√©cution)" >&2
	exit 1
fi
TERMINE
			;;
		dest)
			cat <<TERMINE
if ps axo command | grep -q '^[^ ]*rsync .*--link-dest .verrou.flute/$idarbofactice/'
then
	[ -z "\$1" ] || info "(\$1: verrouill√© par la t√¢che distante $idarbofactice en cours d'ex√©cution)" >&2
	exit 1
fi
TERMINE
			;;
	esac
	
	cat <<TERMINE
[ -z "\$1" ] || info "\$1: verrou caduque (la t√¢che qui l'a pos√© ne tourne plus); on le supprime." >&2
# Si le rsync n'existe plus, alors ce ./deverrouiller est caduque. Afin qu'il ne soit plus appel√©, on marque le dossier comme "en cours de constitution" ("donc ne cherchez pas ./deverrouiller, il n'existe peut-√™tre pas ou peut-√™tre pas compl√®tement").
touch .verrou.flute
exit 0
TERMINE
}

verrouiller()
{
	local ou="$1"
	local libelle="$2"
	if $ou sh -c '[ -d .verrou.flute ] || ! mkdir .verrou.flute'
	then
		# Si le verrou existe, est-il r√©cent (pas encore pr√™t √† l'usage)?
		if $ou find .verrou.flute -maxdepth 0 -mtime -20s | grep -q .
		then
			[ -z "$libelle" ] || info "($libelle: verrou pos√© par une t√¢che concurrente tout juste lanc√©e)" >&2
			return 1
		fi
		# S'il peut √™tre consid√©r√© comme d√©finitif, il est cens√© contenir un script v√©rifiant s'il (le verrou) est encore exploit√©.
		if ! $ou .verrou.flute/deverrouiller "$libelle"
		then
			return 1
		fi
	fi
	
	return 0
}

biverrou()
{
	# NOTE: Verrouillage
	# Un dossier peut √™tre verrouill√©, aussi bien comme source que comme destination. Chaque typologie de verrou embarque son d√©verrouilleur:
	# - par PID pour le source (si ce PID tourne encore au moment de la tentative de d√©verrouillage, c'est qu'il bosse)
	# - par option pass√©e √† rysnc pour la destination (si un ps | grep cette option voit quelque chose, c'est qu'il bosse)
	verrouiller asource "√† la source ($source)" || return 1
	if ! verrouiller adest "√† la cible ($dest)"
	then
		# Bon c'est foutu: on sort, non sans avoir lib√©r√© notre verrou local.
		rm -R "$source/.verrou.flute"
		return 1
	fi
	# On a le verrou! On y pr√©pare notre possible "mort trop brutale pour faire le m√©nage".
	pondreDeverrouiller source > "$source/.verrou.flute/deverrouiller" && chmod a+x "$source/.verrou.flute/deverrouiller"
	pondreDeverrouiller dest | adest sh -c "cat > .verrou.flute/deverrouiller && chmod a+x .verrou.flute/deverrouiller && mkdir .verrou.flute/$idarbofactice/"
}

faire()
{
	local prefixe=
	[ "x$1" = x-p ] && shift && prefixe="$1" && shift || true
source="$1"
dest="$2"
	
	# Tentative d'acqu√©rir le verrou.
	# N√©cessaire car on n'est peut-√™tre pas le seul √† alimenter la destination‚Ä¶ Voire elle est en train d'alimenter une de ses propres cibles, voire m√™me c'est peut-√™tre nous sa cible.
	
	local tmax="`date +%s`"
	tmax="`expr $tmax + \( $DELAI_MAX \* 60 \)`"
	
	local idarbofactice="`hostname`.$$"
	
	while ! biverrou
	do
		if [ `date +%s` -gt $tmax ]
		then
			alerte "# Impossible d'acqu√©rir le verrou au bout de $DELAI_MAX mn." >&2
			return 3
		fi
		sleep 20
	done
	
	_faire
	
	rm -R "$source/.verrou.flute"
	adest rm -R .verrou.flute
}

_faire()
{

# On √©vite de transmettre:
# - nos fichiers de travail
# - les fichiers temporaires d'un autre rsync qui serait en train de nous alimenter
	[ -e "$source/$prefixe.internes.flute" ] || internes > "$source/$prefixe.internes.flute"

	[ -e "$source/$prefixe.deja.flute" ] || internes > "$source/$prefixe.deja.flute"
while true
do
		( cat "$source/$prefixe.internes.flute" ; cd "$source" && ls | sed -e 's#^#- /#' ) > "$source/$prefixe.nouveaux.flute"
		# Si c'est un rsync distant, il faut mettre des \ devant les espaces (merci rsync utilisant ssh et son interpr√©tation shell!).
		destrsync="`echo "$dest" | sed -e '/^[^/]*:/s# #\\\\ #g'`"
		rsync --link-dest .verrou.flute/$idarbofactice/ --exclude-from=- < "$source/$prefixe.deja.flute" -av "$source/" "$destrsync/" && mv "$source/$prefixe.nouveaux.flute" "$source/$prefixe.deja.flute" || break
	sleep 2
		[ `find "$source" -type f -newer "$source/$prefixe.deja.flute" | wc -l` -ne 0 ] || break
done
}

faireConf()
{
	local conf="$1" source="`dirname "$1"`"
	local prefixe="`basename "$conf" .conf.flute`"
	[ "`basename "$conf"`" != .conf.flute ] || prefixe=
	faire -p "$prefixe" "$source" "`cat "$conf"`"
}

analyserParametresEtFaire()
{
	if [ $# -eq 2 -a -d "$1" -a -d "$2" ] && [ "`find "$1" "$2" -name ".*.conf.flute" | wc -l`" -eq 0 ] # Le && plut√¥t que -a, car sh sous FreeBSD 10 √©value le find avant m√™me d'avoir v√©rifi√© que $# -eq 2 et ce sont des dossiers.
	then
		# Ancienne sauce: source, destination pr√©cis√©es sur la ligne de commande. Comment distinguer de deux dossiers (sources) √† synchroniser?
		faire "$1" "$2"
	else
		for d in "$@"
		do
			if [ -f "$d" ]
			then
				faireConf "$d"
			else
				find "$d" -maxdepth 1 -name "*.conf.flute" | \
				(
					trouve=
					while read conf
					do
						trouve=1
						faireConf "$conf"
					done
					[ -n "$trouve" ] || erreur "Aucun fichier .conf.flute dans $d" >&2
				)
			fi
		done
	fi
}

analyserParametresEtFaire "$@"

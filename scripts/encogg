#!/bin/sh

absolutiseScripts() { SCRIPTS="$1" ; echo "$SCRIPTS" | grep -q ^/ || SCRIPTS="`dirname "$2"`/$SCRIPTS" ; } ; absolutiseScripts "`command -v "$0"`" "`pwd`/." ; while [ -h "$SCRIPTS" ] ; do absolutiseScripts "`readlink "$SCRIPTS"`" "$SCRIPTS" ; done ; SCRIPTS="`dirname "$SCRIPTS"`"

TMP=/tmp/temp.$$.encogg
temp=$TMP/morceaux
mkdir -p "$temp"

champ()
{
	cat $TMP/pistes.encogg | awk FNR==${numero} | cut -f $1
}

champs()
{
	arg=1
	while [ "$1" ]
	do
		contenu=`champ ${arg}`
		if [ "${contenu}" ]
		then
			echo $1=${contenu}
		fi
		arg=`expr $arg + 1`
		shift
	done
}

convertir_opus()
{
	fichier="$temp/`champ 1 | tr / :`.opus"
	# Version d'opusenc à la Guillaume, avec track et composer.
	opusenc --bitrate 192 \
		--track "$piste" \
		--title "`champ 1`" \
		--artist "`champ 2`" \
		--composer "`champ 3`" \
		--album "`champ 4`" \
		--date "`champ 5`" \
		"$1" "$fichier"
}

convertir_ogg()
{
	fichier="$temp/`champ 1 | tr / :`.ogg"
	fichier1=$temp/${numero}.ogg
	oggenc -q 5 -o "$fichier1" "$1"
	echo TRACKNUMBER=${piste} > $TMP/champs.encogg
	champs TITLE ARTIST COMPOSER ALBUM DATE DISCNUMBER >> $TMP/champs.encogg
	vorbiscomment -a -R -c $TMP/champs.encogg "$fichier1" "$fichier"
	rm "$fichier1"
}

convertir_m4a()
{
	fichier="$temp/`champ 1 | tr / :`.m4a"
	ffmpeg -v quiet -i "$1" -ab 160k -strict -2 \
		-metadata track="$piste" \
		-metadata title="`champ 1`" \
		-metadata artist="`champ 2`" \
		-metadata composer="`champ 3`" \
		-metadata album="`champ 4`" \
		-metadata year="`champ 5`" \
		"$fichier" < /dev/null # Cet abruti me bouffe mon entrée standard.
}

placer()
{
	champPlace=2
	[ $classique = oui ] && champPlace=3
	place="$dest/$sousdest`champ $champPlace | tr / :`"
	mkdir -p "$place/"
	mv -i "$1" "$place/"
}

faire()
{
	numero=`expr $numero + 1`
	if [ "x$1" = x-n ]
	then
		shift
		piste=$1
		shift
	else
		piste=$numero
	fi
	#fichier="`basename "$1"`"
	#numero=`echo $fichier | cut -d ' ' -f 1 | cut -d - -f 2`
	
	printf "($format) Piste $piste... " > /dev/tty
	convertir_$format "$@"
	placer "$fichier"
	( basename "$fichier" | tr -d '\012' ; printf " -> " ; echo "$place" ) > /dev/tty
}

faireEntreeStandard()
{
	echo Veuillez afficher dans iTunes les colonnes suivantes, dans cet ordre, et les
	echo coller ici, puis faites un Ctrl-D sur une ligne vide:
	echo Titre Interprète Compositeur Album Année Numéro de disque
	cat > $TMP/pistes.encogg

	if [ ! `echo $1 | cut -d '/' -f 1` ]
	then
		slashAuDebut=/
	fi
	sansSlash=`echo -n $1 | tr '/ ' ' *'`
	sansSlash=`echo -n $sansSlash | tr ' *' '/ '`
	numero=0
	ls "$slashAuDebut$sansSlash" | sort -n | while read ligne
	do
		case "$ligne" in
			/*) true ;; # Chemin absolu: notre "$1" désignait un fichier, le ls a donc renvoyé son chemin absolu, nul besoin de remettre son chemin devant.
			*) ligne="$slashAuDebut$sansSlash/$ligne" ;;
		esac
		faire "$ligne"
	done
}

transferer()
{
	until ping -W 2000 -c 1 falbala.local > /dev/null
	do
		sleep 30
	done
	rsync -avz "$dest/" falbala.local:"/Users/Shared/Musique\\ Guillaume/"
	# Pas d'open, car après l'import iTunes joue sans crier gare le premier morceau non des nouveaux mais de tous les importés, donc toujours le même (Shimmy Shake), ce qui est assez lourd à la longue.
	#ssh falbala.local 'sudo -u clotilde open -a iTunes /Users/Shared/Musique\ Guillaume/'
}

faireSelection()
{
	osascript "$SCRIPTS/encogg.applescript" "$TMP/listeselection"
	# On se permet une petite copie locale, les lecteurs optiques préférant parfois tourner à plein régime que d'être soumis à une multitude de petits accès durant l'encodage.
	cat "$TMP/listeselection" | cut -d '	' -f 2 | while read chemin
	do
		dirname "$chemin"
	done | sort -u | while read dossier
	do
		rsync -a "$dossier/" "$TMP/source/"
	done
	
	cut -d '	' -f 3- < $TMP/listeselection > $TMP/pistes.encogg
	numero=0
	cat $TMP/listeselection | cut -d '	' -f 1,2 | while read numPiste fichierOrigine
	do
		fichierOrigine="$TMP/source/`basename "$fichierOrigine"`"
		faire -n "$numPiste" "$fichierOrigine"
	done
	
	if [ $transferer = x ]
	then
		transferer &
	fi
}

lieuCommun()
{
	# Les champs qui peuvent nous donner le titre sous lequel classer les morceaux: on prend la première des infos commune à toutes les pistes.
	for i in 9 10 11 12 13 # Le dernier est un garde-fou, rempli avec toujours la même valeur (Various artists), donc apte à passer le filtre.
	do
		cat $TMP/listeselection | cut -d '	' -f $i | sort -u > $TMP/info
		[ `wc -l < $TMP/info` -eq 1 -a `wc -c < $TMP/info` -gt 1 ] || continue # Il faut que le sort -u nous sort(e) une seule ligne, et composée de plus de caractères que du seul retour à la ligne.
		lieu="`cat $TMP/info`"
		break
	done
}

#quefaire=ogg:.:/Users/gui/mp3
quefaire=opus:.:/Users/gui/mp3
quefaire="m4a:x:/tmp/mp3 $quefaire" # Si c'est pour Clo, c'est pour l'iPhone, donc AAC.

analyserParametres()
{
	classique=non
	sousdest="Récup +/" # Par défaut on encode vers notre dossier Récup + (Récup comme récupéré, parce qu'on n'a pas acheté nous-mêmes le morceau, + parce que, l'ayant encodé nous-mêmes, on est confiants dans sa qualité).
	> "$TMP/parametres"
	while [ $# -gt 0 ]
	do
		case "$1" in
			-c|--classique) classique=oui ;;
			-m|--moi) sousdest= ;; # Si l'achat est de nous, il va dans le dossier principal.
			*) echo "$1" >> "$TMP/parametres" ;;
		esac
		shift
	done
}

analyserParametres "$@"

for passe in $quefaire
do
	format="`echo "$passe" | cut -d : -f 1`"
	transferer="`echo "$passe" | cut -d : -f 2`"
	dest="`echo "$passe" | cut -d : -f 3-`"
if grep -q . < "$TMP/parametres"
then
	faireEntreeStandard "`cat "$TMP/parametres"`"
else
	#echo '### Utilisation: '$0' <disque>'
	#exit 1
	faireSelection
fi
done

wait

chmod -R u+w "$TMP/source"
rm -R $TMP/
